diff --git a/nx_inflate.c b/nx_inflate.c
index 1ac36e1..d42a2b3 100644
--- a/nx_inflate.c
+++ b/nx_inflate.c
@@ -589,7 +589,7 @@ inf_forever:
 			s->inf_state = inf_state_zlib_dictid;
 			s->dict_id = 0;
 			s->dict_len = 0;
-			//fprintf(stderr, "%d, need dictionary\n", __LINE__);
+			fprintf(stderr, "%d, need dictionary\n", __LINE__);
 		}
 		else {
 			s->inf_state = inf_state_inflate; /* go to inflate proper */
@@ -605,7 +605,7 @@ inf_forever:
 			s->dict_id = (s->dict_id << 8) | (c & 0xff);
 			++ s->inf_held;
 		}
-		//fprintf(stderr, "%d, dictionary id %x\n", __LINE__, s->dict_id);
+		fprintf(stderr, "%d, dictionary id %x\n", __LINE__, s->dict_id);
 		strm->adler = s->dict_id; /* asking user to supply this dict with dict_id */
 		s->inf_state = inf_state_zlib_dict;
 		s->inf_held = 0;
@@ -796,6 +796,7 @@ static int nx_amend_history_with_dict(nx_streamp s, int *hlen, int *dlen )
 	
 	return 0;
 }
+extern void nx_print_dde(nx_dde_t *ddep, const char *msg);
 
 static int nx_inflate_(nx_streamp s, int flush)
 {
@@ -926,9 +927,12 @@ decomp_state:
 			nx_amend_history_with_dict(s, &hlen, &dlen );
 
 			/* sum is integral of 16 */
+			cmdp->cpb.in_histlen = 0;
 			putnn(cmdp->cpb, in_histlen, ((hlen + dlen) / NXQWSZ));
 			ASSERT(!!s->dict && !!s->fifo_out);
 
+			fprintf(stderr,"%d: hist %d dictlen %d\n", __LINE__, hlen, dlen);
+			
 			if (dlen > 0)
 				nx_append_dde(ddl_in, s->dict, dlen);
 
@@ -943,10 +947,10 @@ decomp_state:
 				put32(cmdp->cpb, out_crc, INIT_CRC );
 				put32(cmdp->cpb, out_adler, INIT_ADLER);
 			}
-			/* raw mode will set this again for the next dictionary */
-			s->dict_len = 0;
+
+			s->last_comp_ratio = NX_MAX( NX_MIN(1000UL, s->last_comp_ratio), 100L );
 			
-			print_dbg_info(s, __LINE__);				
+			print_dbg_info(s, __LINE__);
 		}
 		else {
 			s->history_len = (s->history_len + NXQWSZ - 1) / NXQWSZ;
@@ -977,12 +981,11 @@ decomp_state:
 		put32(cmdp->cpb, out_crc, INIT_CRC );
 		put32(cmdp->cpb, out_adler, INIT_ADLER);
 
-		/* Assuming 10% compression ratio initially; I use the
-		   most recently measured compression ratio as a
-		   heuristic to estimate the input and output
+		/* We use the most recently measured compression ratio
+		   as a heuristic to estimate the input and output
 		   sizes. If we give too much input, the target buffer
 		   overflows and NX cycles are wasted, and then we
-		   must retry with smaller input size. 1000 is 100%  */
+		   must retry with smaller input size. 1000 is 100% */
 		s->last_comp_ratio = 1000UL;
 	}
 
@@ -1000,6 +1003,7 @@ decomp_state:
 	source_sz = getp32(ddl_in, ddebc); /* total bytes going in to engine */
 	ASSERT( source_sz > s->history_len );
 
+	fprintf(stderr, "%d: source_sz %d\n", __LINE__,source_sz);
 	/*
 	 * NX target buffers
 	 */
@@ -1035,6 +1039,10 @@ decomp_state:
 	   ratio is 10% we want 10KB if input */
 	uint32_t source_sz_expected = (uint32_t)(((uint64_t)target_sz_expected * s->last_comp_ratio + 1000L)/1000UL);
 
+
+	fprintf(stderr, "%d: source_sz_ex %d target_sz_ex %d last_comp_ra %d\n",
+		__LINE__, source_sz_expected, target_sz_expected, s->last_comp_ratio);	
+	
 	/* do not include input side history in the estimation */
 	source_sz = source_sz - s->history_len;
 
@@ -1054,7 +1062,7 @@ decomp_state:
 	target_space_retries = 0;
 
 restart_nx:
-
+	fprintf(stderr, "%d: source_sz %d\n", __LINE__,source_sz);
  	putp32(ddl_in, ddebc, source_sz);  
 
 	/* fault in pages */
@@ -1062,6 +1070,9 @@ restart_nx:
 	nx_touch_pages_dde(ddl_in, source_sz, nx_config.page_sz, 0);
 	nx_touch_pages_dde(ddl_out, target_sz, nx_config.page_sz, 1);
 
+	nx_print_dde(ddl_in, "source dict then data");
+	nx_print_dde(ddl_out, "target");	
+	
 	/* 
 	 * send job to NX 
 	 */
@@ -1333,6 +1344,9 @@ offsets_state:
 
 	s->resuming = 1;
 
+	/* raw mode will set this again for the next dictionary */
+	s->dict_len = 0;
+
 	if (s->is_final == 1 || cc == ERR_NX_OK) {
 
 		/* copy trailer bytes to temp storage */
@@ -1389,12 +1403,12 @@ int nx_inflateSetDictionary(z_streamp strm, const Bytef *dictionary, uInt dictLe
 		prt_err("inflateSetDictionary error: gzip format does not permit dictionary\n");
 		return Z_STREAM_ERROR;
 	}
-
+	fprintf(stderr,"at %d\n", __LINE__);
 	if (s->inf_state != inf_state_zlib_dict && s->wrap == HEADER_ZLIB ) {
 		prt_err("inflateSetDictionary error: inflate did not ask for a dictionary\n");
 		return Z_STREAM_ERROR;
 	}
-
+	fprintf(stderr,"at %d\n", __LINE__);
 	if (s->dict == NULL) {
 		/* one time allocation until inflateEnd() */
 		s->dict_alloc_len = NX_MAX( INF_MAX_DICT_LEN, dictLength);
@@ -1417,15 +1431,16 @@ int nx_inflateSetDictionary(z_streamp strm, const Bytef *dictionary, uInt dictLe
 		}
 	}
 	s->dict_len = 0;
-
+	fprintf(stderr,"at %d\n", __LINE__);
 	/* copy dictionary in and also calculate it's checksum */
 	adler = INIT_ADLER;
 	cc = nx_copy(s->dict, (char *)dictionary, dictLength, NULL, &adler, s->nxdevp);
+	s->zstrm->adler = adler;
 	if (cc != ERR_NX_OK) {
 		prt_err("nx_copy dictionary error\n");
 		return Z_STREAM_ERROR;
 	}
-
+	fprintf(stderr,"at %d\n", __LINE__);
 	/* Got here due to inflate() returning Z_NEED_DICT which should
 	   have saved the dict_id found in the zlib header to
 	   s->dict_id; raw blocks do not have a dictionary id */
@@ -1440,7 +1455,7 @@ int nx_inflateSetDictionary(z_streamp strm, const Bytef *dictionary, uInt dictLe
 	   means that we must truncate the history in fifo_out to the
 	   maximum of 32KB and dictLength; recall the NX rounding
 	   requirements */
-	
+	fprintf(stderr,"at %d\n", __LINE__);	
 	return Z_OK;
 
 
diff --git a/nx_zlib.c b/nx_zlib.c
index 539e535..55cfed0 100644
--- a/nx_zlib.c
+++ b/nx_zlib.c
@@ -404,7 +404,7 @@ int nx_touch_pages_dde(nx_dde_t *ddep, long buf_sz, long page_sz, int wr)
 	return ERR_NX_OK;
 }
 
-static void nx_print_dde(nx_dde_t *ddep, const char *msg)
+void nx_print_dde(nx_dde_t *ddep, const char *msg)
 {
 	uint32_t indirect_count;
 	uint32_t buf_len;
diff --git a/samples/zpipe_dict.c b/samples/zpipe_dict.c
index 9d7d80b..5df7ef9 100644
--- a/samples/zpipe_dict.c
+++ b/samples/zpipe_dict.c
@@ -57,7 +57,7 @@
 #  define SET_BINARY_MODE(file)
 #endif
 
-#define CHUNK 16384
+#define CHUNK (1<<20) /* 16384 */
 
 #define CHECK_ERR(err, msg) do {if (err != Z_OK) { fprintf(stderr, "%s error: %d\n", msg, err); }} while(0)
 
